import type { ResponseMessage, RequestMessage } from 'vscode-languageserver-protocol'

// Set of functions copied from wasm_exec.js to read strings from memory.
const decoder = new TextDecoder()

const getInt64 = (mem: DataView, addr: number) => {
  const low = mem.getUint32(addr, true)
  const high = mem.getInt32(addr + 4, true)
  return low + high * 4294967296
}

const loadString = (mem: DataView, addr: number) => {
  const saddr = getInt64(mem, addr)
  const len = getInt64(mem, addr + 8)
  return decoder.decode(new DataView(mem.buffer, saddr, len))
}

/**
 * Type exposes a private type necessary to manually invoke Go exported funcs.
 */
interface ExtendedGo extends Go {
  /**
   * Manually calls Go functions exposed to JS.
   *
   * This is the only way to call exposed function without adding it to 'globalThis' property.
   * Will be replaced when '//go:wasmexport' is available.
   *
   * @see https://github.com/golang/go/issues/42372
   *
   * @param callbackId Go callback ID generated by `syscall/js`.
   */
  _makeFuncWrapper: <TParam, TReturn>(callbackId: number) => (p: TParam) => TReturn
}

/**
 * Checks if Go instance contains expected private fields and acts as a TypeScript
 * type guard.
 *
 * @param go Go instance created by 'wasm_exec.js'
 */
const supportsGoFuncWrappers = (go: Go): go is ExtendedGo => {
  return '_makeFuncWrapper' in go
}

/**
 * Setups Go object for gnopls server to send and receive LSP messages via passed MessagePort.
 *
 * @param go Go instance.
 * @param port MessagePort used for communication.
 */
export const configureGoInstance = (go: Go, port: MessagePort) => {
  if (!supportsGoFuncWrappers(go)) {
    throw new Error('unsupported version of wasm_exec.js')
  }

  let requestListener: ((req: string) => void) | null = null

  // Prepare WebAssembly import object so gnopls would be able
  // to communicate via message port with a client.
  //
  // See: /internal/js/imports_js.go
  go.importObject.lsp = {
    writeMessage: (slicePtr: number) => {
      let rawMsg = ''

      try {
        rawMsg = loadString(go.mem, slicePtr)

        // Skip header as it's not used by LSP client.
        if (rawMsg.startsWith('Content-Length')) {
          return
        }

        const msg: ResponseMessage & RequestMessage = JSON.parse(rawMsg)
        port.postMessage(msg)
      } catch (err) {
        console.error('gnopls.lspWriteMessage: failed to handle LSP message: ', err)
      }
    },
    closeWriter: () => {
      // Called on server shut down, feel free to implement cleanup logic.
    },
    registerCallback: (callbackId: number) => {
      // Register Go callback to listen for incoming LSP messages from client.
      //
      // See: https://medium.com/towardsdev/go-webassembly-internals-part-1-a7ccdafe6822
      requestListener = go._makeFuncWrapper<string, void>(callbackId)
    },
  }

  // Helper to report errors back to LSP client
  const reportFatalError = (req: RequestMessage, msg: string) => {
    console.error(`gnopls: ${msg}`)

    const { jsonrpc, id } = req
    port.postMessage({
      jsonrpc,
      id,
      error: {
        message: msg,
      },
    })
  }

  // Subscribe and pass incoming messages to gnopls server.
  port.onmessage = ({ data }: MessageEvent<RequestMessage>) => {
    if (!requestListener) {
      reportFatalError(data, 'cannot handle request before server started!')
      return
    }

    try {
      const content = JSON.stringify(data)
      const body = `Content-Length: ${content.length}\r\n\r\n${content}`
      requestListener(body)
    } catch (err) {
      reportFatalError(data, `failed to handle message: ${err}`)
    }
  }
}